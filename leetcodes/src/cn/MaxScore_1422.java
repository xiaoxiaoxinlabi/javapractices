public class MaxScore_1422 {

//  给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。
//「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。

//  示例 1：
//
//  输入：s = "011101"
//  输出：5
//  解释：
//  将字符串 s 划分为两个非空子字符串的可行方案有：
//  左子字符串 = "0" 且 右子字符串 = "11101"，得分 = 1 + 4 = 5
//  左子字符串 = "01" 且 右子字符串 = "1101"，得分 = 1 + 3 = 4
//  左子字符串 = "011" 且 右子字符串 = "101"，得分 = 1 + 2 = 3
//  左子字符串 = "0111" 且 右子字符串 = "01"，得分 = 1 + 1 = 2
//  左子字符串 = "01110" 且 右子字符串 = "1"，得分 = 2 + 1 = 3

//  只要遍历上述n-1种可能的分割方法，计算每种分割方法的分数，其中最大的就是答案。
//  只对数组进行了两次遍历，所以时间复杂度是O(n)O(n)的，空间复杂度为O(1)O(1)。
  public static int maxScore1(String s){
    int res = 0;
    char [] chars = s.toCharArray();
    int left = 0, right = 0;
//    先统计所有的1 的数量一开始先统计整个字符串中有多少个1，赋值给right，这个时候表示左字符串为空，右字符串为s的情况。
    for(char c: chars){
      if(c == '1'){
        right++;
      }

//      以索引i为分割点，将字符串分为[0, i]和[i + 1, s.length - 1]两个部分。要求左右子串都不为空，所以i的取值范围是0 <= i < s.length() - 1。

      for(int i = 0; i < s.length()-1; i ++){
//        在i不断右移动的过程中，如果chars[i] == '0'，说明左边字符串0的个数+1
        if(chars[i] == '0'){
          left++;
//          否则该字符为1且从右边被划分到左边了right--
        }else{
          right--;
        }
//        每一次i移动都对应着一种分割方式，所以要求每种分割方法的分数，其中最大的，就在循环中res = Math.max(res, left + right);
        res = Math.max(res, left + right);
      }
    }

    return res;

  }


}
