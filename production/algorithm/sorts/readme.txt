
交换排序--冒泡排序
1，比较相邻的元素，如果第一个比第二个大，就交换它们
2，对每一对相邻元素作同样的工作，从开始第一对到结尾最后一对，完成之后，最后的元素将是最大的元素
3，针对所有元素重复以上步骤，除了最后一个。




交换--快速
1,取第一个元素作为切分元素，即基准元素： a[low];
2,设定一个左指针：left，指向第一个元素； 然后从数组的左端开始向右扫描，直到找到一个大于等于a[low]的元素
(首次循环一般选择切分元素对立的一面开始)
3，设定一个右指针：right，指向最后一个元素；再从数组的右端开始向左扫描，直到找到一个小于等于a[low]的元素
4，交换这两个元素的位置；如此就可以保证，左指针left的左侧元素都不大于切分元素a[low],右指针right的右侧的元素都不小于a[low];
5，当两个指针相遇（left ，right 指向同一个元素）时，只需要将切分元素a[low]和左子数组最右边的元素a[right]交换后返回right即可；



插入--直接插入
1，将第一个元素当做已经排好序的序列
2，从第二个元素（下标为1）开始直到最后一个元素，依次将待排序的元素插入到排好序的序列中
3，将待插入元素依次与已经排好序的序列的最右边依次向左进行比较，将比待插入元素大的值依次向后挪动，直到找到比待插入元素小的值
4，将待插入元素插入到找到的值的后边




插入--希尔(shellSort)
直接插入排序的间隔gap： 1
希尔排序的间隔gap： h
思想：使数组中任意间隔为h的元素都是有序的。这样的数组被称为h有序数组。换句话说，一个h有序的数组就是h个互相独立的有序数组编织在一起组成的一个数组。

1,确定间隔序列
	1.1，采用 3*h + 1 的方式确定最大间隔
	1.2，确定好的间隔序列之间一定是互质的（最大公约数只有1和本身）

2，分别对每个增量间隔进行直接插入排序
3，将待插入元素： a[i]   插入到a[i-h],a[i - 2*h],a[i - 3*h]之中

3，然后依次缩小间隔（按照递增的反向进行递减），直到缩小最后间隔 = 1



选择--简单选择排序

思想：找到数组中的最小元素，然后数组第一个元素交换，再从剩余的数组中找出最小的元素和第二个元素进行交换，直到整个数组有序为止；
外循环：控制交换次数
内循环：控制比较
交换次数：N次（N个元素）

1，找到数组中最小的元素
2，将它和数组的第一个元素交换位置（如果第一个元素最小，则自己和自己交换）
3，在剩下的元素中找到最小的元素，将它和数组的第二个交换位置
4，循环，直到整个数组有序



选择--堆排序
大顶堆：升序排列
	根节点（父节点）大于其左右子节点
	a[i] > a[2 * i + 1] + 1 && a[2 * i + 2]
小顶堆：降序排列
	根节点（父节点）小于其左右子节点
	a[i] < a[2 * i + 1] && a[2 * i + 2]

父节点索引：（i-1）/2
左孩子节点索引：i * 2 + 1
右孩子节点索引：i * 2 + 2
思想：
1，首先将待排序的数组构造成一个大顶堆，此时，整个数组的最大值就是堆数组的顶端元素（父节点）
2，将顶端的数与末尾的数交换，此时末尾的数为最大值，剩余待排序数组个数为:n-1;
3，将剩余的(n - 1)个数在构造成大顶堆，再将顶端数与（n-1）位置的数交换，反复，直到数组有序



1，构造堆（大顶堆，小顶堆）
	第一次保证0~0位置的元素大顶堆
	第二次保证0~1位置的元素大顶堆
	第三次保证0~2位置的元素大顶堆
	直到保证0~n-1位置的元素大顶堆
	（每次新插入的数据都与其父节点比较，如果插入数据比父节点大，则与父节点进行交换）

2，固定最大值再构造堆
	将顶端数据与最后一位数交换，然后将剩余的数再构造成一个大顶堆





归并排序--外排序

自顶向下的归并排序
	思想：采用分治法对左右两边的子数组进行排序，然后归并

	1，将数组分为长度相等的两个子数组
	2，将子数组排序为有序数组
	3，然后在将他们合并为一个子序列（每次都是从未比较的两个子序列的最小值中选出一个更小值）
	
自底向上的归并排序
	注意：在每一轮归并中，最后一次归并的第二个子数组可能比第一个子数组要小
	1，首先进行两两归并（把每个元素想象成一个大小为1的数组）
	2，然后是四四归并（将两个大小为2的数组归并成一个有4个元素的数组）
	3，然后是八八归并（将两个大小为4的数组归并成一个有8个元素的数组）
	4，一直持续进行归并
	



桶排序

桶排序的基本思想是：把数组 arr 划分为n个大小相同子区间（桶），每个（桶）子区间各自排序，最后合并。

以空间换时间

1.找出待排序数组中的最大值max、最小值min
2.我们使用 动态数组ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max-min)/arr.length+1
3.遍历数组 arr，计算每个元素 arr[i] 放的桶
4.每个桶各自排序
5.遍历桶数组，把排序好的元素放进输出数组



Let's take a quick look at the steps required to perform a bucket sort:

1，Set up an array of our initially empty buckets
2，Distribute our elements into their appropriate buckets
3，Sort each bucket
4，Concatenate the sorted buckets together to recreate the full list


https://blog.csdn.net/afei__/article/details/82965834


































