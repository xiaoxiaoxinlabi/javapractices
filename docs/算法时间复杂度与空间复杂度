算法时间复杂度：
    反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好反映出算法的优劣与否
    语句频度（时间频度）：一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。
    计算方式：T(n) = O(f(n))     （其公式为 算法的渐进时间复杂度： f(n) 表示每行代码执行次数之和，  O 表示正比例关系）

    常见的时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)

    求解算法的时间复杂度的具体步骤是：
        　⑴ 找出算法中的基本语句；
            算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体
            如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。
          ⑵ 计算基本语句的执行次数的数量级；
            只需计算基本语句执行次数的数量级
          ⑶ 用大Ο记号表示算法的时间性能。
            将基本语句执行次数的数量级放入大Ο记号中。

    分别对几个常见的时间复杂度进行示例说明：
        (1)、O(1)-常数阶
            无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)

            Temp=i; i=j; j=temp;
            三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)
            注意：果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)


        (2)、O(n)-线性阶
            a=0;
            b=1;                      ①
            for (i=1;i<=n;i++) ②
            {
                s=a+b;　　　　③
                b=a;　　　　　④
                a=s;　　　　　⑤

             }

            语句1的频度：2；语句2的频度： n；语句3的频度： n-1；语句4的频度：n-1；语句5的频度：n-1
            T(n)=2+n+3(n-1)=4n-1=O(n)

        (3)、O(logN)-对数阶
            i=1;     ①
            while (i<=n)
               i=i*2; ②

            语句1的频度是1；
            语句2的频度：
                在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。
                假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n
                也就是说当循环 log2^n 次以后，这个代码就结束了
            T(n)=O(logn)

        (4)、O(nlogN)--线性对数阶

            for(m=1; m<n; m++)
            {
                i = 1;
                while(i<n)
                {
                    i = i * 2;
                }
            }

            将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)
            T(n)=O(nlogN)


        (5)、O(n2)
            交换i和j的内容
             sum=0；
                 for(i=1;i<=n;i++)
                    for(j=1;j<=n;j++)
                     sum++；


             如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)
             T(n)= O(n²)；


        (6)、O(n³)--立方阶，(n^k)--K次方阶O

            for(i=0;i<n;i++)
                {
                   for(j=0;j<i;j++)
                   {
                      for(k=0;k<j;k++)
                         x=x+2;
                   }
                }

            当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6
            T(n) = O(n³)    （O(n³)相当于三层n循环，其它的类似）



算法空间复杂度：
    算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间。是对一个算法在运行过程中临时占用存储空间大小的量度存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面
    空间复杂度比较常用的有：O(1)、O(n)、O(n²)

    (1)、空间复杂度 O(1)
        如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
        int i = 1;
        int j = 2;
        ++i;
        j++;
        int m = i + j;
        代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)

    (2)、空间复杂度 O(n)
        int[] m = new int[n]
        for(i=1; i<=n; ++i)
        {
           j = i;
           j++;
        }

        第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)
    (3)、
